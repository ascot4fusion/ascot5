"""Tools for processing numerical arrays."""
import warnings
from typing import Generator, Union, Any, Sized, Optional, overload
from contextlib import contextmanager

import unyt
import numpy as np

Scalar = Union[int, float]
"""Type of a scalar."""

ArrayLike = Union[list[Scalar], np.ndarray, unyt.unyt_array]
"""Type of a numerical array."""


class VariableValidator:
    """Object for validating numerical variables.

    This object is generated by :func:`.validate_variables` context manager.
    """

    unitless: list[tuple[str, str]]
    """List of unitless arguments (for printing the warning message)."""

    def __init__(self) -> None:
        self.unitless = []

    #pylint: disable=too-many-arguments
    def validate(
            self,
            name: str,
            value: Scalar | ArrayLike | None,
            expected_shape: tuple[int],
            units: Optional[str]=None,
            dtype: str="f8",
            default: Optional[np.ndarray]=None
            ) -> np.ndarray | unyt.unyt_array:
        """Validate a variable.

        This function checks that the variable has or can be cast into the
        expected format (shape, units, dtype) and returns the variable cast.

        Parameters
        ----------
        name : str
            Name of the variable (for generating error messages).
        value : int | float | list | np.ndarray | unyt.unyt_array
            Value of the variable.
        expected_shape : tuple[int], *optional*
            Expected shape of the variable if applicable.

            Special case is ``(1,)`` for when the argument is expected to be 1D
            vector with undefined length.
        units : str, *optional*
            Units of the variable.
        dtype : str, *optional*
            Data type of the variable.
        default : int | float | list | np.ndarray | unyt.unyt_array, *optional*
            If the value is None, this value cast in the expected format is
            returned.

        Returns
        -------
        val : np.ndarray | unyt.array
            The variable cast to the expected format.
        """
        def use_default_if_none(
                arr: Scalar | ArrayLike | None,
                ) -> Scalar | ArrayLike:
            if arr is None:
                if default is None:
                    raise ValueError(
                        "Default value must be provided for optional arguments: "
                        f"{name}"
                        )
                if units is not None:
                    return unyt.unyt_array(default, units)
                return default
            return arr

        def cast_array(arr: Scalar | ArrayLike) -> np.ndarray | unyt.unyt_array:
            if isinstance(arr, (int, float, list, tuple)):
                return np.array(arr, dtype=dtype)
            if isinstance(arr, (np.ndarray, unyt.unyt_array)):
                return arr.astype(dtype)
            raise ValueError(
                f"Argument '{name}' must be int, float, list, numpy array, or "
                f"unyt array, not '{type(arr)}'"
                )

        def cast_shape(
                arr: np.ndarray | unyt.unyt_array,
                ) -> np.ndarray | unyt.unyt_array:
            if expected_shape == ():
                if arr.size != 1:
                    raise ValueError(
                        f"Argument '{name}' has incompatible shape '{arr.shape}', "
                        f"expected scalar."
                        )
            elif expected_shape == (-1,):
                if arr.ndim != 1 and not ( arr.ndim == 2 and 1 in arr.shape ):
                    raise ValueError(
                        f"Argument '{name}' has incompatible shape '{arr.shape}', "
                        f"expected 1D vector."
                        )
            elif( arr.size > 1 and
                arr.shape != expected_shape and
                arr.T.shape != expected_shape ):
                raise ValueError(
                    f"Argument '{name}' has incompatible shape '{arr.shape}', "
                    f"expected: {expected_shape}."
                    )
            return arr.reshape(expected_shape)

        def cast_units(
                arr: np.ndarray | unyt.unyt_array,
                ) -> np.ndarray | unyt.unyt_array:
            if units is not None:
                if isinstance(arr, unyt.unyt_array):
                    try:
                        arr.convert_to_units(units)
                        return arr
                    except unyt.exceptions.UnitConversionError:
                        raise ValueError(
                            f"Argument '{name}' has incompatible units "
                            f"'{arr.units}', expected '{units}'."
                            ) from None
                if units != "1":
                    self.unitless.append((name, units))
                return unyt.unyt_array(arr, units)
            return arr

        arr = use_default_if_none(value)
        arr = cast_array(arr)
        arr = cast_shape(arr)
        arr = cast_units(arr)
        return arr

    def flush(self) -> None:
        """Print warning messages for unitless arguments and reset object."""
        if self.unitless:
            names = ", ".join([f"'{name}'" for name, _ in self.unitless])
            units = ", ".join([f"'{unit}'" for _, unit in self.unitless])
            warnings.warn(
                f"Argument(s) {names} given without dimensions. Assumed {units}.",
                stacklevel=5,
                )
            self.unitless.clear()


@contextmanager
def validate_variables() -> Generator[Any, Any, Any]:
    """Context manager for validating numerical variables.

    Examples
    --------

    .. code-block:: python

        with validate_variables() as v:
            x = v.validate("x", x, (2,2), "m", default=np.array([1.0, 1.0]))

    """
    validator = VariableValidator()
    try:
        yield validator
    finally:
        validator.flush()


def size(x: Any) -> int:
    """Return the size of x.

    Separate function is needed because unyt.array.quantity has size but
    not len.

    Parameters
    ----------
    x : Any
        Object to get size of.

    Returns
    -------
    val : int
        Size of ``x``.
    """
    try:
        return x.size
    except AttributeError:
        pass
    return len(x)

@overload
def scalar2array(x: None, n: int) -> None: ...

@overload
def scalar2array(x: Any, n: int) -> int: ...

def scalar2array(x: Any, n: int) -> unyt.unyt_array | np.ndarray | None:
    """Convert scalar x to an array of length n.

    If ``x`` is not scalar, it is returned unchanged.

    Parameters
    ----------
    x : Any
        A scalar to convert to array.
    n : int
        Length of the array.

    Returns
    -------
    val : np.ndarray | unyt.array
        Array of length n.
    """
    if x is None:
        return None
    if not isinstance(x, Sized):
        return np.full(n, x)

    if size(x) == 1:
        if hasattr(x, "units"):
            return np.full(n, x) * x.units
        return np.full(n, x)
    return x


def validate_abscissa(
        abscissa: unyt.unyt_array,
        name: str,
        uniform: bool=True,
        periodic: bool=False,
        ) -> None:
    """Check if the abscissa is increasing and otherwise valid.

    Parameters
    ----------
    abscissa : unyt.array
        The abscissa to check.
    name : str
        Name of the abscissa (for the possible error message).
    uniform : bool, *optional*
        If True, check if the abscissa is also uniform.
    periodic : bool, *optional*
        If True, check if the abscissa is also periodic.

    Raises
    ------
    ValueError
        If the abscissa is invalid.
    """
    nx, dx = abscissa.size, np.diff(abscissa)
    if nx < 2:
        raise ValueError(f"{name} must have at least two points.")

    if np.any(dx < 0):
        raise ValueError(f"{name} must be increasing.")

    dx_expected = np.diff( abscissa[[0,-1]] ) / ( nx - 1 )
    if uniform and not np.allclose(dx, dx_expected):
        raise ValueError(f"{name} must be uniform.")

    xmax, xmin = abscissa[-1] + dx[0], abscissa[0]
    nperiod = ( 360 * unyt.deg / (xmax - xmin) ).v
    if periodic and not np.isclose(nperiod, np.round(nperiod)):
        raise ValueError(
            f"{name} must be periodic (the current interval was [{xmin:.2f}, "
            f"`{xmax:.2f}`] i.e. `nperiod = {nperiod:.2f}`)."
            )
