"""Contains classes that represent leafs of the tree data structure."""
from __future__ import annotations

import re
import time
import ctypes
import datetime
from enum import IntFlag, auto
from typing import Any, Optional, Callable, TYPE_CHECKING

import unyt
import numpy as np

from a5py import utils
from a5py.exceptions import AscotDataException, AscotMeltdownError

if TYPE_CHECKING:
    from .tree import TreeManager
    from a5py.data.access.hdf5io import DataAccess


class Status(IntFlag):
    """Status of the data storage."""

    SAVED = auto()
    """Data is stored in a file."""

    STAGED = auto()
    """Data is stored in memory and ready for simulation."""


#pylint: disable=too-few-public-methods
class DataStruct(ctypes.Structure):
    """Expands the ctypes.Structure class to better support data storage."""

    def readonly_carray(
            self, name: str,
            shape: tuple,
            units: Optional[str]=None,
            ) -> np.ndarray | unyt.unyt_array:
        """Return a read-only view on the array within the struct.

        Parameters
        ----------
        name : str
            Name of the array within the struct.
        shape : tuple
            Shape of the array.
        units : str, *optional*
            Units of the array.

        Returns
        -------
        arr : np.ndarray or unyt.array
            Read-only view on the array.
        """
        arr = np.ctypeslib.as_array(getattr(self, name), shape=shape)
        arr.flags.writeable = False
        if units is not None:
            return unyt.unyt_array(arr, units)
        return arr


class Leaf():
    """Leaf of a tree which has no further children managed by the tree.

    A leaf represents an end point of the tree that has no further children
    *managed by the tree*. Each leaf contains metadata: `date` when the data was
    created, user-specified `note` describing the data, and a string called
    `variant` that identifies the exact type of data the leaf contains. The
    variant is used to determine the class to instantiate when the leaf is read
    from the file. The metadata is immutable with the exception of `note`.

    Leaves have attribute `name` which by default is the same as `variant`. When
    the leaf is added to the tree, this name is appended with a running number
    so that the name is unique and can be used to identify given leaf.

    Leaves may contain actual data as well, which may be stored in a file. The
    leaves have access to the file through the `file` attribute.

    This class is intented to be subclassed and each subclass should specify
    their own variant.

    A leaf does not belong to a tree initially.
    """

    _registry: dict[str, type] = {}
    """Mapping between `variant` and the class to instantiate

    This registry is updated each time this class is subclassed by decorating
    the subclass with Leaf.register.
    """

    VARIANT = "leaf"
    """Variant of the data this class represents.

    This attribute is automatically generated by the :meth:`Leaf.register`
    decorator.
    """

    def __init__(
            self,
            date: Optional[str]=None,
            note: Optional[str]=None,
            **kwargs: Any,
            ) -> None:
        """
        Parameters
        ----------
        date
            Date when this data was created.

            If None, assume current date (the data is created now).
        note
            Short note for the user to document this data.
        variant
            What data variant this instance represents.
        **kwargs
            Arguments passed to other constructors in case of multiple
            inheritance.
        """
        super().__init__(**kwargs)
        if date is None:
            date = utils.format2universaldate(datetime.datetime.now())
            time.sleep(0.001) # So that all leaves have different timestamps
        self._date: str = date
        """Date when this data was created."""

        self._note: str = note if note is not None else ""
        """Brief note for the user to document this data."""

        self._name: str = self.__class__.VARIANT
        """Identifies class this leave represents."""

        self._variant: str = self.__class__.VARIANT
        """Name of this leave."""

        self._file: DataAccess | None = None
        """Interface to the HDF5 group associated with this leaf if this leaf is
        both part of a tree and saved to disk.
        """

        self._treemanager: Optional[TreeManager] = None
        """Manager of the tree this leaf belongs to if this leaf is part of
        a tree.
        """

    def __repr__(self) -> str:
        """Return a string representation of this object."""
        return (
            f"<{self.__class__.__name__}(name={self.name}, date={self._date})>"
            )

    @property
    def date(self) -> str:
        """Date when this data was created."""
        return self._date

    @property
    def note(self) -> str:
        """Short note for the user to document this data.

        The note can also specify a `tag` by containing `<tag>` in it. The tag
        can be used as a user-specified reference to the data. See for details.

        The tag must begin with a letter but otherwise it has free form.
        However, once set, any special characters are removed, spaces replaced
        with underscores, and the whole tag is converted to uppercase.
        """
        return self._note

    @note.setter
    def note(self, note: str) -> None:
        _, self._note = Leaf.extract_tag(note)
        if self._treemanager is not None:
            self._treemanager.note_changed(self)

    @property
    def variant(self) -> str:
        """Variant of the data."""
        return self._variant

    @property
    def name(self) -> str:
        """Name of the data."""
        return self._name

    @property
    def status(self) -> Status:
        """Status of the data storage."""
        if self._file is not None:
            return Status.SAVED
        return Status.STAGED

    def activate(self) -> None:
        """Set this data as active.

        Active inputs are used when the simulation is run. Active data variants
        are also used during post-processing by default unless otherwise
        specified.
        """
        if self._treemanager is not None:
            self._treemanager.activate_leaf(self)

    def destroy(self, *, repack: bool=True) -> None:
        """Remove this data permanently.

        Parameters
        ----------
        repack : bool, *optional*
            Repack the file to reduce it's disk size.

            Deleting data in an HDF5 file with h5py only removes its references,
            not the actual data. Repacking copies the data to a new file and
            replaces the original, freeing up space. May take a moment for large
            files.
        """
        if self._treemanager is not None:
            self._treemanager.destroy_leaf(self, repack=repack)


    def save(self) -> None:
        """Store data to disk.

        Raises
        ------
        :class:`.AscotMeltdownError`
            If this data is not part of a tree.
        :class:`.AscotDataException`
            If this data is already saved to disk.
        """
        if self._treemanager is None:
            raise AscotMeltdownError("This data is not part of a tree.")
        if self.status is Status.SAVED:
            raise AscotDataException("Data is already saved to disk.")
        self._file = self._treemanager.save_leaf(self)
        self._save_data()

    def _save_data(self) -> None:
        """Save the actual data"""

    @staticmethod
    def extract_tag(note: str) -> tuple[str | None, str]:
        """Extracts tag from a given leaf's note.

        A note is converted to a tag like this:

        1. The tag is a word or multiple words surrounded by <>.
        2. All special characters are removed (only standard letters and numbers
           are allowed).
        3. The letters are converted to uppercase and spaces to underscore.
        4. If the tag is invalid (empty string or starts with a number), or
           there were multiple tags, raise an exception.
        5. If there were no tag, the default tag is returned instead.

        Note that the returned value is not the actual tag used in the tree if
        there are other leafs with identical tags.

        Returns
        -------
        tag : str
            The tag.
        new_note : str
            The note with the <tag> replaced by the <CONVERTED_TAG>.
        """
        tags = re.findall(r"<(.*?)>", note)
        if not tags:
            return None, note

        if len(tags) > 1:
            raise ValueError("Multiple tags found. Use single '<>'.")

        raw_tag = tags[0].strip()
        clean = re.sub(r"[^A-Za-z0-9 ]", "", raw_tag)
        tag = clean.upper().replace(" ", "_")

        if len(tag) == 0:
            raise ValueError(
                "Tag processed to an empty string. Try adding some letters."
                )
        if tag and tag[0].isdigit():
            raise ValueError("Tag cannot start with a number.")

        new_note = re.sub(r"<.*?>", f"<{tag}>", note, count=1)
        return tag, new_note

    @classmethod
    def register(cls, variant: str) -> Callable[[type[Any]], type[Any]]:
        """Add variant class to registry.

        Use this as a decorator for subclasses.
        """
        def decorator(subclass: type) -> type:
            cls._registry[variant] = subclass
            setattr(subclass, "VARIANT", variant)
            return subclass
        return decorator

    @classmethod
    def create_leaf(
        cls, variant: str, date: str, note: str, **kwargs: Any
        ) -> Leaf:
        """Initialize a Leaf (subclass) based on the name of the variant."""
        leaf_cls = cls._registry.get(variant, cls)
        return leaf_cls(date=date, note=note, **kwargs)


@Leaf.register("input")
class InputVariant(Leaf):
    """Base class for input variants.

    This class stores the data either on the file or in memory.

    No data is contained initially.
    """

    def __init__(
            self, date: Optional[str]=None, note: Optional[str]=None,
            ) -> None:
        super().__init__(date=date, note=note)
        self._cdata: Any | None = None
        """Data stored in memory."""

    @property
    def status(self) -> Status:
        """Status of the data storage.

        Raises
        ------
        :class:`.AscotDataException`
            If this instance has no data.
        """
        if self._cdata is not None and self._file is not None:
            return Status.SAVED | Status.STAGED
        if self._file is not None:
            return Status.SAVED
        if self._cdata is not None:
            return Status.STAGED
        raise AscotDataException("This instance has no data.")

    def stage(self) -> None:
        """Make this data ready for simulation or evaluation.

        The memory consumption may increase significantly, so remember to
        unstage afterwards with :meth:`unstage`.

        Raises
        ------
        :class:`.AscotDataException`
            If this instance is already staged.
        """
        if self.status & Status.STAGED:
            raise AscotDataException("This instance is already staged.")


    def unstage(self) -> None:
        """Undo the effect of :meth:`stage` and free consumed memory.

        Raises
        ------
        :class:`.AscotDataException`
            If this instance is not staged or if the data is not stored to disk.
        """
        if self.status is Status.STAGED:
            raise AscotDataException(
                "Please save this data to disk before trying to unstage it."
                )
        if self.status is Status.SAVED:
            raise AscotDataException("This instance is not staged.")

    def export(self) -> dict[str, np.ndarray]:
        """Return a dictionary with sufficient data to duplicate this instance.

        Returns
        -------
        data : dict[str, np.ndarray or unyt.array]
            Data that can be passed to the create method to duplicate this
            instance.
        """
        return {}


@Leaf.register("output")
class OutputVariant(utils.ImmutableStorage, Leaf):
    """Base class for simulation data.

    Instances of this class contain all metadata associated with the simulation.
    In addition to to `date`, `note` and `name`, this class also contain
    references to all input variants used in the simulation. These are accessed
    via ``outputleaf["category"]``.

    The simulation data is stored by various diagnostics objects, and instances
    of this class only contain references to those.

    Initially there are no diagnostics.
    """

    def __init__(
            self, date: Optional[str]=None,
            note: Optional[str]=None,
            inputs: Optional[dict[str, Leaf]]=None,
            **kwargs: Any,
            ) -> None:
        """
        Parameters
        ----------
        date : str
            Date when this data was created.
        note : str
            Short note for the user to document this data.
        inputs : dict [str, `Leaf`]
            Inputs used in this simulation by category.
        **kwargs
            Arguments passed to other constructors in case of multiple
            inheritance.
        """
        super().__init__(date=date, note=note, **kwargs)
        self._inputs: list[str] = []
        """Inputs used in the simulation."""

        self._diagnostics: dict[str, type] = {}
        """Diagnostics used in the simulation and the names which they are
        referenced within this class.
        """

        if inputs is not None:
            for category, leaf in inputs.items():
                self[category] = leaf
                self._inputs.append(category)

    @property
    def contents(self) -> str:
        """A string representation of the contents."""
        return utils.undecorate(self._get_decorated_contents())

    def __repr__(self) -> str:
        """Return a string representation of this object."""
        inputs = []
        for category in self._inputs:
            data = self[category]
            inputs.append(f"({category}:{data.name})")
        return (
            f"<{self.__class__.__name__}("
            f"name={self.name}, "
            f"inputs={inputs}, "
            f"diagnostics={list(self._diagnostics.keys())}, "
            f"saved={self._file is not None})>"
            )

    def __getattribute__(self, key: str) -> Any:
        """Return attribute unless it refers to an input not present in the
        simulation.

        Parameters
        ----------
        key : str
            Name of the attribute or input category.

        Returns
        -------
        value : Any
            Value of the attribute.

        Raises
        ------
        :class:`.AscotDataException`
            If the queried input was not used in the simulation.
        """
        if key.startswith("_"):
            return super().__getattribute__(key)
        if self._treemanager is None:
            return super().__getattribute__(key)

        if key in self._treemanager.nodes and key not in self._inputs:
            raise AscotDataException(
                f"Input '{key}' was not used in the simulation."
                )
        return super().__getattribute__(key)

    def _setup(self, params: dict[str, Any]) -> None:
        """Create diagnostics and make them ready for simulation.

        Subclasses should override this method.

        Parameters
        ----------
        params : dict
            Parameters which are parsed to initialized all diagnostics.
        """
        _ = params
        raise NotImplementedError(
            f"{self.__class__.__name__} must implement '_setup'"
        )

    def _load(self, file: DataAccess) -> None:
        """Setup diagnostics from file.

        Subclasses should extend this method to create diagnostics based on the
        data on file. This implementation checks that the diagnostics are not
        already set and sets the filemanager.
        """
        if self.status is Status.SAVED:
            raise AscotMeltdownError("Cannot load this data twice.")
        if len(self._diagnostics):
            raise AscotMeltdownError("Diagnostics setup already.")

        self._file = file

    def _get_decorated_contents(self) -> str:
        """Get a string representation of the contents decorated with ANSI
        escape sequences.
        """
        contents = ""
        contents += utils.decorate(f"{self.name.ljust(15)}", bold=True)
        contents += f" {self.date}"
        contents += f"\n{self.note}\n"

        contents += utils.decorate("\nInputs:\n", color="purple",
                                   underline=True, bold=True)
        for category in self._inputs:
            leaf = self[category]

            contents += utils.decorate(category.ljust(8), color="green")
            contents += utils.decorate(f"{leaf.name.ljust(15)}", bold=True)
            contents += f" {leaf.date}"
            contents += f"\n{''.ljust(8)}{leaf.note}\n"

        return contents

    def show_contents(self) -> None:
        """Show on screen the metadata of this run among with all the inputs
        that were used.
        """
        print(self._get_decorated_contents())
