"""RF wave fields.

The RF wave fields are used to store the 2D electromagnetic wave fields
generated by codes like TORIC. These fields are defined by their complex 
fields, E_R = Re(E_R) + i*Im(E_R) and have a phase dependence on the toroidal
mode number and the angular frequency in time.

This implementation follows the publication by:
G. Kramer et al, "A description of the full-particle-orbit
following SPIRAL code for simulating fast-ion experiments in tokamaks",
Plasma Phys. Control. Fusion 55 (2013) 025013

in Equation (20).
"""
import h5py
import numpy as np

from .coreio.fileapi import add_group
from .coreio.treedata import DataGroup

class rffield(DataGroup):
    """Electromagnetic wave fields generated by the TORIC code.
    """

    def read(self):
        """Read data from HDF5 file.

        Returns
        -------
        data : dict
            Data read from HDF5 stored in the same format as is passed to
            :meth:`write_hdf5`.
        """
        out = {}
        with self as f:
            for key in f:
                out[key] = f[key][:]
        return out
    
    @staticmethod
    def write_hdf5(fn, rmin=None, rmax=None, 
                   zmin=None, zmax=None, 
                   Er=None, Ez=None, Ephi=None, 
                   Br=None, Bz=None, Bphi=None,
                   omega=None, ntor=None,
                   desc=None):
        """Write input data to the HDF5 file.

        Parameters
        ----------
        fn : str
            Full path to the HDF5 file.
        rmin : float
            Minimum radial coordinate.
        rmax : float
            Maximum radial coordinate.
        zmin : float
            Minimum axial coordinate.
        zmax : float
            Maximum axial coordinate.
        Er : ndarray, complex
            Radial electric field, complex evaluated.
        Ez : ndarray, complex
            Axial electric field, complex evaluated.
        Ephi : ndarray, complex
            Toroidal electric field, complex evaluated.
        Br : ndarray, complex
            Radial magnetic field, complex evaluated.
        Bz : ndarray, complex
            Axial magnetic field, complex evaluated.
        Bphi : ndarray, complex
            Toroidal magnetic field, complex evaluated.
        omega: float
            Frequency of the RF wave.
        ntor: int
            Toroidal mode number of the RF wave.

        Returns
        -------
        name : str
            Name, i.e. "<type>_<qid>", of the new input that was written.

        Raises
        ------
        ValueError
            If inputs were not consistent.
        """
        # If everything is None, then we will just skip it.
        if (rmin is None and rmax is None and zmin is None and zmax is None and
            Er is None and Ez is None and Ephi is None and Br is None and
            Bz is None and Bphi is None):
            return ""

        if Er.shape != Ez.shape:
            raise ValueError("Er and Ez do not have the same shape.")
        if Er.shape != Ephi.shape:
            raise ValueError("Er and Ephi do not have the same shape.")
        if Er.shape != Br.shape:
            raise ValueError("Er and Br do not have the same shape.")
        if Er.shape != Bz.shape:
            raise ValueError("Er and Bz do not have the same shape.")
        if Er.shape != Bphi.shape:
            raise ValueError("Er and Bphi do not have the same shape.")
        
        # Checking that the inputs are of complex type.
        if (Er.dtype != np.complex128 or Ez.dtype != np.complex128 or
            Ephi.dtype != np.complex128 or Br.dtype != np.complex128 or
            Bz.dtype != np.complex128 or Bphi.dtype != np.complex128):
            raise ValueError("Electric and magnetic field are expected" + 
                             " to be complex fields for the RF waves")

        parent = "rffield"
        group  = "rffield"
        gname  = ""
        with h5py.File(fn, "a") as f:
            g = add_group(f, parent, group, desc=desc)
            gname = g.name.split("/")[-1]

            g.create_dataset("rmin", data=(rmin,), dtype="f8")
            g.create_dataset("rmax", data=(rmax,), dtype="f8")
            g.create_dataset("zmin", data=(zmin,), dtype="f8")
            g.create_dataset("zmax", data=(zmax,), dtype="f8")
            g.create_dataset("nr", data=(Er.shape[0],), dtype="i4")
            g.create_dataset("nz", data=(Er.shape[1],), dtype="i4")

            g.create_dataset("Er_real", data=Er.real, dtype="f8")
            g.create_dataset("Ez_real", data=Ez.real, dtype="f8")
            g.create_dataset("Ephi_real", data=Ephi.real, dtype="f8")
            g.create_dataset("Er_imag", data=Er.imag, dtype="f8")
            g.create_dataset("Ez_imag", data=Ez.imag, dtype="f8")
            g.create_dataset("Ephi_imag", data=Ephi.imag, dtype="f8")

            g.create_dataset("Br_real", data=Br.real, dtype="f8")
            g.create_dataset("Bz_real", data=Bz.real, dtype="f8")
            g.create_dataset("Bphi_real", data=Bphi.real, dtype="f8")
            g.create_dataset("Br_imag", data=Br.imag, dtype="f8")
            g.create_dataset("Bz_imag", data=Bz.imag, dtype="f8")
            g.create_dataset("Bphi_imag", data=Bphi.imag, dtype="f8")

            g.create_dataset("omega", data=(omega,), dtype="f8")
            g.create_dataset("ntor", data=(ntor,), dtype="i4")

        return gname
    @staticmethod
    def create_dummy():
        """Create dummy data that has correct format and is valid, but can be
        non-sensical.

        For the RF input, the C-code has been built to allow for backwards
        compatibility with old input files not containing the RF fields. So
        this class will not write anything unless there is actual data.

        Returns
        -------
        data : dict
            Input data that can be passed to ``write_hdf5`` method of
            a corresponding type.
        """
        # Does nothing.
        return {}

    @staticmethod
    def create_test_fields():
        """Create test data for the RF fields.

        Returns
        -------
        data : dict
            Input data that can be passed to ``write_hdf5`` method of
            a corresponding type.
        """
        rmin = 0.1
        rmax = 10.0
        zmin = -10.0
        zmax = 10.0
        nr = 10
        nz = 10
        Er = np.ones((nr, nz), dtype=np.complex128)
        Ez = np.zeros((nr, nz), dtype=np.complex128)
        Ephi = np.zeros((nr, nz), dtype=np.complex128)
        Br = np.zeros((nr, nz), dtype=np.complex128)
        Bz = np.zeros((nr, nz), dtype=np.complex128)
        Bphi = np.zeros((nr, nz), dtype=np.complex128)
        omega = 1.0
        ntor = 1

        return {"rmin": rmin, "rmax": rmax, "zmin": zmin, "zmax": zmax,
                "Er": Er, "Ez": Ez, "Ephi": Ephi, "Br": Br, "Bz": Bz,
                "Bphi": Bphi, "omega": omega, "ntor": ntor}

