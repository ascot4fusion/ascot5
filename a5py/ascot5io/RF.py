"""RF wave fields.

The RF wave fields are used to store the 2D/3D electromagnetic wave fields
generated by codes like TORIC. 

This encapsulates the routines to read and write the fields for both the
guiding center formalism, that requires the polarized components of the
electric field; and the full orbit that requires the full electromagnetic
fields.

-- GUIDING CENTER --
The polarized components are the natural outputs of codes like TORIC or
AORSA, and are widely used. The implementation of the fields in ASCOT 
has been directly ported from the ORBIT-RF code.

M. Choi et al, PoP (2010)

-- FULL ORBIT --
The fields are defined by their complex fields, E_R = Re(E_R) + i*Im(E_R) 
and have a phase dependence on the toroidal mode number and the angular 
frequency in time.

This implementation follows the publication by:
G. Kramer et al, "A description of the full-particle-orbit
following SPIRAL code for simulating fast-ion experiments in tokamaks",
Plasma Phys. Control. Fusion 55 (2013) 025013

in Equation (20).
"""
import h5py
import numpy as np

from .coreio.fileapi import add_group
from .coreio.treedata import DataGroup

class RF2D(DataGroup):
    """Electromagnetic wave fields in cylindrical components for a 2D field,
    with fixed toroidal mode number.
    """

    def read(self):
        """Read data from HDF5 file.

        Returns
        -------
        data : dict
            Data read from HDF5 stored in the same format as is passed to
            :meth:`write_hdf5`.
        """
        out = {}
        with self as f:
            for key in f:
                out[key] = f[key][:]
        return out
    
    @staticmethod
    def write_hdf5(fn, rmin=None, rmax=None, 
                   zmin=None, zmax=None, 
                   Er=None, Ez=None, Ephi=None, 
                   Br=None, Bz=None, Bphi=None,
                   omega=None, ntor=None,
                   desc=None):
        """Write input data to the HDF5 file.

        Parameters
        ----------
        fn : str
            Full path to the HDF5 file.
        rmin : float
            Minimum radial coordinate.
        rmax : float
            Maximum radial coordinate.
        zmin : float
            Minimum axial coordinate.
        zmax : float
            Maximum axial coordinate.
        Er : ndarray, complex
            Radial electric field, complex evaluated.
        Ez : ndarray, complex
            Axial electric field, complex evaluated.
        Ephi : ndarray, complex
            Toroidal electric field, complex evaluated.
        Br : ndarray, complex
            Radial magnetic field, complex evaluated.
        Bz : ndarray, complex
            Axial magnetic field, complex evaluated.
        Bphi : ndarray, complex
            Toroidal magnetic field, complex evaluated.
        omega: float
            Frequency of the RF wave.
        ntor: int
            Toroidal mode number of the RF wave.

        Returns
        -------
        name : str
            Name, i.e. "<type>_<qid>", of the new input that was written.

        Raises
        ------
        ValueError
            If inputs were not consistent.
        """
        # If everything is None, then we will just skip it.
        if (rmin is None and rmax is None and zmin is None and zmax is None and
            Er is None and Ez is None and Ephi is None and Br is None and
            Bz is None and Bphi is None):
            return ""

        if Er.shape != Ez.shape:
            raise ValueError("Er and Ez do not have the same shape.")
        if Er.shape != Ephi.shape:
            raise ValueError("Er and Ephi do not have the same shape.")
        if Er.shape != Br.shape:
            raise ValueError("Er and Br do not have the same shape.")
        if Er.shape != Bz.shape:
            raise ValueError("Er and Bz do not have the same shape.")
        if Er.shape != Bphi.shape:
            raise ValueError("Er and Bphi do not have the same shape.")
        
        # Checking that the inputs are of complex type.
        if (Er.dtype != np.complex128 or Ez.dtype != np.complex128 or
            Ephi.dtype != np.complex128 or Br.dtype != np.complex128 or
            Bz.dtype != np.complex128 or Bphi.dtype != np.complex128):
            raise ValueError("Electric and magnetic field are expected" + 
                             " to be complex fields for the RF waves")
        
        nr = Er.shape[0]
        nz = Er.shape[1]

        parent = "RF"
        group  = "RF2D"
        gname  = ""
        with h5py.File(fn, "a") as f:
            g = add_group(f, parent, group, desc=desc)
            gname = g.name.split("/")[-1]

            g.create_dataset("rmin", (1,), data=(rmin,), dtype="f8")
            g.create_dataset("rmax", (1,), data=(rmax,), dtype="f8")
            g.create_dataset("zmin", (1,), data=(zmin,), dtype="f8")
            g.create_dataset("zmax", (1,), data=(zmax,), dtype="f8")
            g.create_dataset("nr", (1,), data=(nr,), dtype="i4")
            g.create_dataset("nz", (1,), data=(nz,), dtype="i4")

            g.create_dataset("Er_real", (nz, nr), data=Er.real.T, dtype="f8")
            g.create_dataset("Ez_real", (nz, nr), data=Ez.real.T, dtype="f8")
            g.create_dataset("Ephi_real", (nz, nr), data=Ephi.real.T, dtype="f8")
            g.create_dataset("Er_imag", (nz, nr), data=Er.imag.T, dtype="f8")
            g.create_dataset("Ez_imag", (nz, nr), data=Ez.imag.T, dtype="f8")
            g.create_dataset("Ephi_imag", (nz, nr), data=Ephi.imag.T, dtype="f8")

            g.create_dataset("Br_real", (nz, nr), data=Br.real.T, dtype="f8")
            g.create_dataset("Bz_real", (nz, nr), data=Bz.real.T, dtype="f8")
            g.create_dataset("Bphi_real", (nz, nr), data=Bphi.real.T, dtype="f8")
            g.create_dataset("Br_imag", (nz, nr), data=Br.imag.T, dtype="f8")
            g.create_dataset("Bz_imag", (nz, nr), data=Bz.imag.T, dtype="f8")
            g.create_dataset("Bphi_imag", (nz, nr), data=Bphi.imag.T, dtype="f8")

            g.create_dataset("omega", (1,), data=(omega,), dtype="f8")
            g.create_dataset("ntor", (1,), data=(ntor,), dtype="i4")

        return gname
    @staticmethod
    def create_dummy():
        """Create dummy data that has correct format and is valid, but can be
        non-sensical.

        For the RF input, the C-code has been built to allow for backwards
        compatibility with old input files not containing the RF fields. So
        this class will not write anything unless there is actual data.

        Returns
        -------
        data : dict
            Input data that can be passed to ``write_hdf5`` method of
            a corresponding type.
        """
        # Does nothing.
        return {}

    @staticmethod
    def create_test_fields():
        """Create test data for the RF fields.

        Returns
        -------
        data : dict
            Input data that can be passed to ``write_hdf5`` method of
            a corresponding type.
        """
        rmin = 0.1
        rmax = 10.0
        zmin = -10.0
        zmax = 10.0
        nr = 10
        nz = 10
        Er = np.ones((nr, nz), dtype=np.complex128)
        Ez = np.zeros((nr, nz), dtype=np.complex128)
        Ephi = np.zeros((nr, nz), dtype=np.complex128)
        Br = np.zeros((nr, nz), dtype=np.complex128)
        Bz = np.zeros((nr, nz), dtype=np.complex128)
        Bphi = np.zeros((nr, nz), dtype=np.complex128)
        omega = 1.0
        ntor = 1

        return {"rmin": rmin, "rmax": rmax, "zmin": zmin, "zmax": zmax,
                "Er": Er, "Ez": Ez, "Ephi": Ephi, "Br": Br, "Bz": Bz,
                "Bphi": Bphi, "omega": omega, "ntor": ntor}

class RF3D(DataGroup):
    """Electromagnetic wave fields in cylindrical components for a 3D field.
    """

    def read(self):
        """Read data from HDF5 file.

        Returns
        -------
        data : dict
            Data read from HDF5 stored in the same format as is passed to
            :meth:`write_hdf5`.
        """
        out = {}
        with self as f:
            for key in f:
                out[key] = f[key][:]
        return out
    
    @staticmethod
    def write_hdf5(fn, rmin=None, rmax=None, 
                   zmin=None, zmax=None, 
                   Er=None, Ez=None, Ephi=None, 
                   Br=None, Bz=None, Bphi=None,
                   omega=None, ntor=None,
                   desc=None):
        """Write input data to the HDF5 file.

        Parameters
        ----------
        fn : str
            Full path to the HDF5 file.
        rmin : float
            Minimum radial coordinate.
        rmax : float
            Maximum radial coordinate.
        zmin : float
            Minimum axial coordinate.
        zmax : float
            Maximum axial coordinate.
        Er : ndarray, complex
            Radial electric field, complex evaluated.
        Ez : ndarray, complex
            Axial electric field, complex evaluated.
        Ephi : ndarray, complex
            Toroidal electric field, complex evaluated.
        Br : ndarray, complex
            Radial magnetic field, complex evaluated.
        Bz : ndarray, complex
            Axial magnetic field, complex evaluated.
        Bphi : ndarray, complex
            Toroidal magnetic field, complex evaluated.
        omega: float
            Frequency of the RF wave.
        ntor: int
            Toroidal mode number of the RF wave.

        Returns
        -------
        name : str
            Name, i.e. "<type>_<qid>", of the new input that was written.

        Raises
        ------
        ValueError
            If inputs were not consistent.
        """
        # If everything is None, then we will just skip it.
        if (rmin is None and rmax is None and zmin is None and zmax is None and
            Er is None and Ez is None and Ephi is None and Br is None and
            Bz is None and Bphi is None):
            return ""

        if Er.shape != Ez.shape:
            raise ValueError("Er and Ez do not have the same shape.")
        if Er.shape != Ephi.shape:
            raise ValueError("Er and Ephi do not have the same shape.")
        if Er.shape != Br.shape:
            raise ValueError("Er and Br do not have the same shape.")
        if Er.shape != Bz.shape:
            raise ValueError("Er and Bz do not have the same shape.")
        if Er.shape != Bphi.shape:
            raise ValueError("Er and Bphi do not have the same shape.")
        
        # Checking that the inputs are of complex type.
        if (Er.dtype != np.complex128 or Ez.dtype != np.complex128 or
            Ephi.dtype != np.complex128 or Br.dtype != np.complex128 or
            Bz.dtype != np.complex128 or Bphi.dtype != np.complex128):
            raise ValueError("Electric and magnetic field are expected" + 
                             " to be complex fields for the RF waves")
        
        nr = Er.shape[0]
        nz = Er.shape[1]
        nphi = Er.shape[2]

        parent = "RF"
        group  = "RF3D"
        gname  = ""
        with h5py.File(fn, "a") as f:
            g = add_group(f, parent, group, desc=desc)
            gname = g.name.split("/")[-1]

            g.create_dataset("rmin", (1,), data=(rmin,), dtype="f8")
            g.create_dataset("rmax", (1,), data=(rmax,), dtype="f8")
            g.create_dataset("zmin", (1,), data=(zmin,), dtype="f8")
            g.create_dataset("zmax", (1,), data=(zmax,), dtype="f8")
            g.create_dataset("nr", (1,), data=(nr,), dtype="i4")
            g.create_dataset("nz", (1,), data=(nz,), dtype="i4")
            g.create_dataset("nphi", (1,), data=(nphi,), dtype="i4")

            g.create_dataset("Er_real", (nz, nr), data=Er.real.T, dtype="f8")
            g.create_dataset("Ez_real", (nz, nr), data=Ez.real.T, dtype="f8")
            g.create_dataset("Ephi_real", (nz, nr), data=Ephi.real.T, dtype="f8")
            g.create_dataset("Er_imag", (nz, nr), data=Er.imag.T, dtype="f8")
            g.create_dataset("Ez_imag", (nz, nr), data=Ez.imag.T, dtype="f8")
            g.create_dataset("Ephi_imag", (nz, nr), data=Ephi.imag.T, dtype="f8")

            g.create_dataset("Br_real", (nz, nr), data=Br.real.T, dtype="f8")
            g.create_dataset("Bz_real", (nz, nr), data=Bz.real.T, dtype="f8")
            g.create_dataset("Bphi_real", (nz, nr), data=Bphi.real.T, dtype="f8")
            g.create_dataset("Br_imag", (nz, nr), data=Br.imag.T, dtype="f8")
            g.create_dataset("Bz_imag", (nz, nr), data=Bz.imag.T, dtype="f8")
            g.create_dataset("Bphi_imag", (nz, nr), data=Bphi.imag.T, dtype="f8")

            g.create_dataset("omega", (1,), data=(omega,), dtype="f8")
            g.create_dataset("ntor", (1,), data=(ntor,), dtype="i4")

        return gname
    
    @staticmethod
    def create_dummy():
        """Create dummy data that has correct format and is valid, but can be
        non-sensical.

        For the RF input, the C-code has been built to allow for backwards
        compatibility with old input files not containing the RF fields. So
        this class will not write anything unless there is actual data.

        Returns
        -------
        data : dict
            Input data that can be passed to ``write_hdf5`` method of
            a corresponding type.
        """
        # Does nothing.
        return {}

    @staticmethod
    def create_test_fields():
        """Create test data for the RF fields.

        Returns
        -------
        data : dict
            Input data that can be passed to ``write_hdf5`` method of
            a corresponding type.
        """
        rmin = 0.1
        rmax = 10.0
        zmin = -10.0
        zmax = 10.0
        nr = 10
        nz = 10
        nphi = 2
        Er = np.ones((nr, nz, nphi), dtype=np.complex128)
        Ez = np.zeros((nr, nz, nphi), dtype=np.complex128)
        Ephi = np.zeros((nr, nz, nphi), dtype=np.complex128)
        Br = np.zeros((nr, nz, nphi), dtype=np.complex128)
        Bz = np.zeros((nr, nz, nphi), dtype=np.complex128)
        Bphi = np.zeros((nr, nz, nphi), dtype=np.complex128)
        omega = 1.0
        ntor = 1

        return {"rmin": rmin, "rmax": rmax, "zmin": zmin, "zmax": zmax,
                "Er": Er, "Ez": Ez, "Ephi": Ephi, "Br": Br, "Bz": Bz,
                "Bphi": Bphi, "omega": omega, "ntor": ntor}

class RF2D_Stix(DataGroup):
    """Electromagnetic wave fields in polarized components for a 2D field,
    with fixed toroidal mode number.
    """

    def read(self):
        """Read data from HDF5 file.

        Returns
        -------
        data : dict
            Data read from HDF5 stored in the same format as is passed to
            :meth:`write_hdf5`.
        """
        out = {}
        with self as f:
            for key in f:
                out[key] = f[key][:]
        return out
    
    @staticmethod
    def write_hdf5(fn, rmin=None, rmax=None, 
                   zmin=None, zmax=None, 
                   omega=None, ntor=None,
                   Eplus_re: float=None, Eplus_im: float=None,
                   Eminus_re: float=None, Eminus_im: float=None,
                   kperp: float=None,
                   costheta: float=None, sintheta: float=None,
                   include_Eminus: bool=True, include_stochastic: bool=True,
                   include_vpara_kick: bool=True, include_phase_factor: bool=True,
                   desc=None):
        """Write input data to the HDF5 file.

        Parameters
        ----------
        fn : str
            Full path to the HDF5 file.
        rmin : float
            Minimum radial coordinate.
        rmax : float
            Maximum radial coordinate.
        zmin : float
            Minimum axial coordinate.
        zmax : float
            Maximum axial coordinate.
        omega: float
            Frequency/ies of the RF wave(s).
        ntor: int
            Toroidal mode number of the RF wave(s).
        Eplus_re: float
            Real part of the E+ field.
        Eplus_im: float
            Imaginary part of the E+ field.
        Eminus_re: float
            Real part of the E- field.
        Eminus_im: float
            Imaginary part of the E- field.
        kperp: float
            Perpendicular wave number.
        costheta: float
            Cosine of the angle theta.
        sintheta: float
            Sine of the angle theta.
        include_Eminus: bool
            Whether to include the E- field.
        include_stochastic: bool
            Whether to include stochastic effects.
        include_vpara_kick: bool
            Whether to include parallel velocity kick.
        include_phase_factor: bool
            Whether to include phase factor.

        Returns
        -------
        name : str
            Name, i.e. "<type>_<qid>", of the new input that was written.

        Raises
        ------
        ValueError
            If inputs were not consistent.
        """
        # If everything is None, then we will just skip it.
        if (rmin is None and rmax is None and zmin is None and zmax is None and
            omega is None and ntor is None and
            Eplus_re is None and Eplus_im is None and
            Eminus_re is None and Eminus_im is None and
            kperp is None and costheta is None and sintheta is None):
            return ""

        if Eplus_im.shape != Eplus_re.shape:
            raise ValueError("Eplus_im and Eplus_re do not have the same shape.")
        if Eplus_im.shape != Eminus_re.shape:
            raise ValueError("Eplus_im and Eminus_re do not have the same shape.")
        if Eplus_im.shape != Eminus_im.shape:
            raise ValueError("Eplus_im and Eminus_im do not have the same shape.")
        if Eplus_im.shape != kperp.shape:
            raise ValueError("Eplus_im and kperp do not have the same shape.")
        if Eplus_im.shape != costheta.shape:
            raise ValueError("Eplus_im and costheta do not have the same shape.")
        if Eplus_im.shape != sintheta.shape:
            raise ValueError("Eplus_im and sintheta do not have the same shape.")
        
        if Eplus_re.squeeze().ndim == 2:
            nwaves = 1
        else:
            raise NotImplementedError("Only single wave implementation is available.")
        nr = Eplus_re.shape[0]
        nz = Eplus_re.shape[1]

        parent = "RF"
        group  = "RF2D_Stix"
        gname  = ""
        with h5py.File(fn, "a") as f:
            g = add_group(f, parent, group, desc=desc)
            gname = g.name.split("/")[-1]

            g.create_dataset("rmin", (1,), data=(rmin,), dtype="f8")
            g.create_dataset("rmax", (1,), data=(rmax,), dtype="f8")
            g.create_dataset("zmin", (1,), data=(zmin,), dtype="f8")
            g.create_dataset("zmax", (1,), data=(zmax,), dtype="f8")
            g.create_dataset("nr", (1,), data=(nr,), dtype="i4")
            g.create_dataset("nz", (1,), data=(nz,), dtype="i4")
            g.create_dataset("nwaves", (1,), data=(nwaves,), dtype="i4")

            g.create_dataset("Eplus_re", (nz, nr), data=Eplus_re.T, dtype="f8")
            g.create_dataset("Eplus_im", (nz, nr), data=Eplus_im.T, dtype="f8")
            g.create_dataset("Eminus_re", (nz, nr), data=Eminus_re.T, dtype="f8")
            g.create_dataset("Eminus_im", (nz, nr), data=Eminus_im.T, dtype="f8")
            g.create_dataset("kperp", (nz, nr), data=kperp.T, dtype="f8")
            g.create_dataset("costheta", (nz, nr), data=costheta.T, dtype="f8")
            g.create_dataset("sintheta", (nz, nr), data=sintheta.T, dtype="f8")

            g.create_dataset("omega", (nwaves,), data=(omega,), dtype="f8")
            g.create_dataset("ntor", (nwaves,), data=(ntor,), dtype="i4")

            # Adding the flags.
            include_Eminus = 1 if include_Eminus else 0
            include_stochastic = 1 if include_stochastic else 0
            include_vpara_kick = 1 if include_vpara_kick else 0
            include_phase_factor = 1 if include_phase_factor else 0

            g.create_dataset("include_Eminus", (1,), data=(include_Eminus,), dtype="i4")
            g.create_dataset("include_stochastic", (1,), data=(include_stochastic,), dtype="i4")
            g.create_dataset("include_vpara_kick", (1,), data=(include_vpara_kick,), dtype="i4")
            g.create_dataset("include_phase_factor", (1,), data=(include_phase_factor,), dtype="i4")

        return gname
    
    @staticmethod
    def create_dummy():
        """Create dummy data that has correct format and is valid, but can be
        non-sensical.

        For the RF input, the C-code has been built to allow for backwards
        compatibility with old input files not containing the RF fields. So
        this class will not write anything unless there is actual data.

        Returns
        -------
        data : dict
            Input data that can be passed to ``write_hdf5`` method of
            a corresponding type.
        """
        # Does nothing.
        return {}

    @staticmethod
    def create_test_fields():
        """Create test data for the RF fields.

        Returns
        -------
        data : dict
            Input data that can be passed to ``write_hdf5`` method of
            a corresponding type.
        """
        rmin = 0.1
        rmax = 10.0
        zmin = -10.0
        zmax = 10.0
        nr = 10
        nz = 10
        Eplus_re = np.ones((nr, nz), dtype=np.float64)
        Eplus_im = np.zeros((nr, nz), dtype=np.float64)
        Eminus_re = np.zeros((nr, nz), dtype=np.float64)
        Eminus_im = np.zeros((nr, nz), dtype=np.float64)
        kperp = np.zeros((nr, nz), dtype=np.float64)
        costheta = np.zeros((nr, nz), dtype=np.float64)
        sintheta = np.zeros((nr, nz), dtype=np.float64)
        omega = np.array([1.0], dtype=np.float64)
        ntor = np.array([11], dtype=np.int32)
        include_Eminus = True
        include_stochastic = True
        include_vpara_kick = True
        include_phase_factor = True

        return {"rmin": rmin, "rmax": rmax, "zmin": zmin, "zmax": zmax,
                "nr": nr, "nz": nz, "Eplus_re": Eplus_re, "Eplus_im": Eplus_im,
                "Eminus_re": Eminus_re, "Eminus_im": Eminus_im, "kperp": kperp,
                "costheta": costheta, "sintheta": sintheta, "omega": omega,
                "ntor": ntor, "include_Eminus": include_Eminus,
                "include_stochastic": include_stochastic,
                "include_vpara_kick": include_vpara_kick,
                "include_phase_factor": include_phase_factor}
