# -*- coding: utf-8 -*-
"""
Created on Tue Oct 24 17:20:57 2023

@author: Ian Dolby

This script contains a function which returns an ASCOT5-ready bfield dictionary from an input TRANSP plasma state dataset, having adjusted for different COCOS conventions.

It also modifies psi0 very slightly to prevent an interpolation error I was getting when running an earlier version of ASCOT5, which kept aborting lots of markers due to invalid input.
"""

import numpy as np
import netCDF4 as nc
import scipy.interpolate

from . import cocos


def bfield_from_plasma_state_dataset(TRANSP_plasma_state_dataset, COCOS_in=5, COCOS_out=3, quiet=False):
    """
    ##
    """
    TPSD = TRANSP_plasma_state_dataset
    
    psipol = TPSD.variables['psipol'][:] # As a function of rho_eq
    rgrid  = TPSD.variables['R_grid'][:]
    zgrid  = TPSD.variables['Z_grid'][:]
    
    axisr = TPSD.variables['R_axis'][:]
    axisz = TPSD.variables['Z_axis'][:]
    psi   = TPSD.variables['PsiRZ'][:]
    psi_interp = scipy.interpolate.RegularGridInterpolator(points=(TPSD.variables['R_grid'][:], TPSD.variables['Z_grid'][:]), values=TPSD.variables['PsiRZ'][:].T, method='cubic')
    psi0  = psi_interp((TPSD.variables['R_axis'][:], TPSD.variables['Z_axis'][:]))
    psi1  = psipol[-1]
    bphi  = TPSD.variables['BphiRZ'][:]
    nr = len(rgrid)
    nz = len(zgrid)
    rmax = np.max(rgrid)
    rmin = np.min(rgrid)
    zmax = np.max(zgrid)
    zmin = np.min(zgrid)
    br = TPSD.variables['BRRZ'][:].T*0 # These variables are only for the non-equilibrium values. ASCOT5 will calculate the equilibrium components from psi
    bz = TPSD.variables['BZRZ'][:].T*0
    
    """
    Now we check the COCOS number and convert if necessary.
    """
    cocos.cocos_check(TPSD, COCOS=COCOS_in, quiet=True) # Check that the input COCOS is as expected; this will break if not.
    new_equilibrium = cocos.cocos_transform(TPSD, COCOS_in=COCOS_in, COCOS_out=COCOS_out, quiet=quiet)
    
    psi  = new_equilibrium['psi'].T
    psi0 = new_equilibrium['psi0']
    psi1 = new_equilibrium['psi1']
    bphi = new_equilibrium['bphi'].T
    
    
    """
    Now we need to linearly interpolate psi onto a finer grid to prevent the interpolator in ASCOT5 producing regions of imaginary rho.
    The procedure is to generate a finely-interpolated grid of psi, and then to modify the value of psi0 to be safely beyond the
     troublesome values generated by the spline interpolation.
     We will assume that 10^-6 times the value of psi0 - psi1 is a sufficiently large value by which to change psi0 that the danger
     is mitigated, a small enough to ensure a negligible effect on the physics.
     We then return the original psi grid to avoid interfering with the interpolation done by ASCOT5.
    """
    R_array = rgrid
    Z_array = zgrid
    R_mg, Z_mg = np.meshgrid(R_array, Z_array, indexing='ij')
    R_mg_flat = R_mg.flatten()
    Z_mg_flat = Z_mg.flatten()
    old_R_Z_pairs = (R_mg_flat, Z_mg_flat)
    
    sf = 5
    R_array_large = np.linspace(rmin, rmax, sf * nr)
    Z_array_large = np.linspace(zmin, zmax, sf * nz)
    R_mg_large, Z_mg_large = np.meshgrid(R_array_large, Z_array_large, indexing='ij')
    R_mg_large_flat = R_mg_large.flatten()
    Z_mg_large_flat = Z_mg_large.flatten()
    new_R_Z_pairs = (R_mg_large_flat, Z_mg_large_flat)
    
    psi_flat = psi.flatten()
    
    psi_large = scipy.interpolate.griddata(old_R_Z_pairs, psi_flat, new_R_Z_pairs, method='cubic')
    
    """ Now modify psi0 by adding a small value (using psi0 - psi1 so that the sign is right)
    """
    tolerance = 1e-6
    psi0_shift = (psi0 - psi1) * tolerance
    psi0 = psi0 + psi0_shift
    
    """ Check that the problem has been avoided
    """
    rho_squared = (psi_large - psi0)/(psi1 - psi0)
    if rho_squared[rho_squared < 0].size !=0:
        print("**ERROR**: The rho grid contains imaginary components. Check the input grid or change the tolerance.")
        raise ValueError
    
    
    bfield_dict = {'axisr': axisr, 'axisz': axisz, 'psi': psi, 'psi0': psi0, 'psi1': psi1, 'bphi': bphi, \
                   'nr': nr, 'nz': nz, 'rmax': rmax, 'rmin': rmin, 'zmax': zmax, 'zmin': zmin, 'br': br, 'bz': bz}
    return bfield_dict


if __name__ == '__main__':
    plotyn = 0
    
    run_ID = '134020D30'
    TRANSP_plasma_state_directory = '../../134020D30/'
    
    TRANSP_plasma_state_filename = TRANSP_plasma_state_directory + run_ID + "_ps_ts1_state.cdf"
    TRANSP_plasma_state_data = nc.Dataset(TRANSP_plasma_state_filename)
    
    
    bfield_test_plasma_state = bfield_from_plasma_state_dataset(TRANSP_plasma_state_dataset=TRANSP_plasma_state_data, COCOS_in=5, COCOS_out=3)
    
    
    if plotyn == 1:
        
        
        
        plt.show()
