"""Poincare run templates.
"""
import numpy as np
import unyt
import copy

from scipy.interpolate import interp1d
from scipy.integrate import solve_ivp

from a5py.data.marker  import Marker
from a5py.data.options import Opt
from a5py.physlib import parseunits
from a5py.exceptions import *

class PoincareTemplates():

    def marker_poincare(self, nmrk=100, rhomin=0, rhomax=1, tor=None,
                        pol=0*unyt.deg, time=0*unyt.s, pitch=1.0, species=None,
                        energy=None):
        """Generate markers at fixed intervals in radius.

        By default, the generated markers are field lines. Physical particles
        can be generated by passing marker species and mass.

        Parameters
        ----------
        nmrk : int, optional
            Number of markers.
        rhomin : float, optional
            Minimum marker initial rho coordinate.
        rhomax : float, optional
            Maximum marker initial rho coordinate.
        tor : float, optional
            Initial marker toroidal coordinate.

            If None, markers are distributed uniformly in toroidal direction.
        pol : float, optional
            Initial marker poloidal coordinate.

            If None, markers are distributed uniformly in poloidal direction.
        time : float
            Time slice at when field line markers are traced.

            If physical particles are traced, this is the time-instant at when
            the simulation begins.
        pitch : float
            Field line marker direction (1) co- (2) counter-parallel to
            the magnetic field lines.

            If physical particles are traced, this parameter is the guiding
            center pitch (ppar/p) instead.

        species : str, optional
            Marker species to be simulated instead of field lines.

            **IMPORTANT** The simulation mode also needs to be set to GO or GC.
        energy : float
            Marker energy if physical particles are traced.

        Returns
        -------
        gtype : str
            Type of the generated input data.
        data : dict
            Input data that can be passed to ``write_hdf5`` method of
            a corresponding type.

        Raises
        ------
        ValueError
            If species is provided but not energy.
        """
        if species is not None and energy is None:
            raise ValueError("Please provide both species and energy")

        if tor is None:
            tor = 360 * np.random.rand(nmrk,) * unyt.deg
        else:
            tor = tor * np.ones((nmrk,))

        if pol is None:
            pol = 360 * np.random.rand(nmrk,) * unyt.deg
        else:
            pol = pol * np.ones((nmrk,))

        rhovals = np.linspace(rhomin, rhomax, nmrk)
        r, z = self._ascot.input_rhotheta2rz(rhovals, pol, tor, time)

        if species is None:
            mrk = Marker.generate("fl", nmrk)
            mrk["r"][:]     = r
            mrk["z"][:]     = z
            mrk["phi"][:]   = tor
            mrk["pitch"][:] = pitch
            mrk["time"][:]  = time
            return ("fl", mrk)
        else:
            mrk = Marker.generate("gc", nmrk, species=species)
            mrk["r"][:]      = r
            mrk["z"][:]      = z
            mrk["phi"][:]    = tor
            mrk["pitch"][:]  = pitch
            mrk["time"][:]   = time
            mrk["energy"][:] = energy
            return ("gc", mrk)

    @parseunits(tor="deg", pol="deg")
    def options_poincare(self, simmode=4, tor=0*unyt.deg, pol=0*unyt.deg,
                         ntorb=500, nporb=500, both=False, maxrho=False,
                         mhd=False, cpulim=None):
        """Generate options to generate Poincar√© plot data.

        Collisionless orbits are traced for a fixed number of toroidal and
        poloidal transits. The points, where the given poloidal and toroidal
        planes were crossed, are recorded.

        Parameters
        ----------
        simmode : {1, 2, 4}, optional
            Simulation mode (1: gyro-orbit, 2: guiding-center, 4: field line).
        tor : array_like, optional
            Toroidal angle(s) where data is gathered for (R,z) plot(s).
        pol : array_like, optional
            Poloidal angle(s) where data is gathered for (rho,phi) plot(s).
        ntorb : int, optional
            Number of full toroidal orbits before simulation is terminated.
        nporb : int, optional
            Number of full poloidal orbits before simulation is terminated.
        both : bool, optional
            Both ``ntorb`` and ``nporb`` conditions must be met before
            simulation is terminated.
        maxrho : bool, optional
            Terminate marker when it escapes plasma.

            Otherwise the marker is terminated at the wall.
        mhd : bool, optional
            Set ``True`` to enable MHD.
        cpulim : float, optional
            Maximum CPU time spent on simulating a single marker.

            This parameter can be used to ensure the simulation is terminated.

        Returns
        -------
        gtype : str
            Type of the generated input data.
        data : dict
            Input data that can be passed to ``write_hdf5`` method of
            a corresponding type.
        """
        out = Opt.get_default()
        out.update({
            "SIM_MODE":simmode,
            "ENABLE_ADAPTIVE":1,
            "ENABLE_ORBIT_FOLLOWING":1,
            "ENABLE_ORBITWRITE":1,
            "ORBITWRITE_MODE":0,
            "ORBITWRITE_TOROIDALANGLES":tor,
            "ORBITWRITE_POLOIDALANGLES":pol,
            "ORBITWRITE_NPOINT":nporb*pol.size + ntorb*tor.size,
            "ENDCOND_MAX_POLOIDALORBS":nporb,
            "ENDCOND_MAX_TOROIDALORBS":ntorb,
            "ENDCOND_MAXORBS":1,
            "ENDCOND_WALLHIT":1,
            "ENDCOND_MAX_RHO":1.0,
        })

        if both:
            out["ENDCOND_MAXORBS"] = 2
        if maxrho:
            out["ENDCOND_RHOLIM"] = 1
        if cpulim is not None:
            out["ENDCOND_CPUTIMELIM"]  = 1
            out["ENDCOND_MAX_CPUTIME"] = cpulim
        if mhd:
            out["ENABLE_MHD"] = mhd

        return ("opt", out)

    def boozer_tokamak(self, npsi=100, nthgeo=200, nthbzr=200, tol=1e-5,
                       nint=10000, rhomin=0.05, rhomax=0.95):
        """Build mapping from real-space to Boozer coordinates assuming
        axisymmetric tokamak field.

        Parameters
        ----------
        npsi : int, optional
            Number of psi grid points.
        nthgeo : int, optional
            Number of geometrical theta grid points.
        nthbzr : int, optional
            Number of boozer theta grid points.
        nint : int, optional
            Number of points in line integral evaluations.
        rhomin : float, optional
            Minimum rho in the radial grid which cannot be zero since
            the Boozer coordinates cannot be computed there.
        rhomax : float, optional
            Maximum rho in the radial grid which cannot be one since
            the separatrix does not form a closed surface when there is
            an X-point.

        Returns
        -------
        gtype : str
            Type of the generated input data.
        data : dict
            Input data that can be passed to ``write_hdf5`` method of
            a corresponding type.
        """
        inp = self._ascot.input_initialized()
        if "bfield" not in inp:
            raise AscotInitException("bfield not initialized")
        grp  = self._ascot.data._get_group(inp["bfield"])
        d    = grp.read()
        psi0 = d["psi0"]
        psi1 = d["psi1"]

        # ...and this poloidal grid to evaluate values along the contour
        thgrid = np.linspace(0, 2*np.pi, nint)

        # Boozer coordinate psi-grid. Add a little bit of padding to psi0 and
        # psi1 values as otherwise making the contour at those points could
        # yield funny results.
        pmin  = float(psi0 + rhomin**2 * ( psi1 - psi0 ))
        pmax  = float(psi0 + rhomax**2 * ( psi1 - psi0 ))
        psimin  = np.amin([pmin, pmax])
        psimax  = np.amax([pmin, pmax])
        psigrid = np.linspace(psimin, psimax, npsi)
        if psi1 < psi0: psigrid = np.flip(psigrid) # Ensure grid start at psi0

        # Boozer coordinate theta grid
        thgeogrid = np.linspace(0, 2*np.pi, nthgeo)

        # Boozer coordinate nu grid
        thbzrgrid = np.linspace(0, 2*np.pi, nthbzr+1)[:-1]

        # Set up the data tables (psi can be evaluated directly)
        thtable  = np.zeros( (psigrid.size, thgeogrid.size) )
        nutable  = np.zeros( (psigrid.size, thbzrgrid.size) )

        # Helper quantities evaluated when the coordinate transform is made
        qprof = np.zeros(psigrid.shape)
        Iprof = np.zeros(psigrid.shape)
        gprof = np.zeros(psigrid.shape)

        # Calculate Boozer angular coordinates for each psi
        for i in range(psigrid.size):

            # Interpolate the contour points on the fixed (geometrical) theta
            # grid (at OMP we set thetageom=thetabzr=0)
            rhogrid = np.sqrt((psigrid[i]-psi0) / (psi1 - psi0)) \
                * np.ones(thgrid.shape)*unyt.dimensionless
            r, z = self._ascot.input_rhotheta2rz(
                rhogrid, thgrid*unyt.rad, np.zeros(thgrid.shape)*unyt.rad,
                0*unyt.s, tol=tol)

            # Magnetic field along the contour (psi can be used to check that
            # the contour was set properly). Drop the last element in r and z
            # as it is the same as first.
            br, bphi, bz, psi = self._ascot.input_eval(
                r[:-1], 0*unyt.rad, z[:-1], 0*unyt.s,
                "br", "bphi", "bz", "psi")

            bpol  = np.sqrt(br**2 + bz**2)
            bnorm = np.sqrt(br**2 + bphi**2 + bz**2)
            ds    = (np.diff(r) * br + np.diff(z) * bz) / bpol # darc dot e^_pol
            r = r[:-1]; z = z[:-1]

            # The toroidal current term (multiplying this with 2*pi/mu0 gets
            # enclosed toroidal current)
            Iprof[i] = np.sum( ds * bpol ) / ( 2*np.pi )

            # g = R*Bphi, since Bphi ~ 1/R this is a constant
            gprof[i] = r[0] * bphi[0]

            # The (global) safety factor q(psi)
            qprof[i] = np.sum( ds * gprof[i] / ( r**2 * bpol ) ) / ( 2*np.pi )

            # Boozer coordinate Jacobian is (I - qg) / B^2. Setting it fixes the
            # Boozer poloidal angle which we can now solve.
            jac = (Iprof + qprof*gprof)[i] / bnorm**2
            btheta = np.append(
                0*unyt.T*unyt.m, np.cumsum( ds / ( jac * bpol ) ))

            # The above Jacobian is for a periodical theta, so theta[-1] should
            # equal to 2 pi already, but normalize it to remove numerical error
            # (note that the new Jacobian would be J / a)
            a = 2*np.pi / btheta[-1]
            if np.isnan(a) or np.abs(a.v - 1) > 0.1:
                raise ValueError(
                    "Something wrong with Boozer data generation. " +
                    "Theta is not periodic: thetamax/2pi = %f", a)
            btheta *= a
            thtable[i, :] = interp1d(thgrid, btheta, "linear")(thgeogrid)

            # For Boozer toroidal coordinate, we need to integrate the local
            # safety factor along the contour
            nu = gprof[i] * np.append(
                0/(unyt.T*unyt.m), np.cumsum( ds / ( r**2 * bpol ) ) )

            # Interpolate nu used in zeta = phi + nu(psi, theta)
            nutable[i,:] = -interp1d(btheta, nu, 'linear')(thbzrgrid) \
                + qprof[i] * thbzrgrid

        # Flip the data grids to set indices right
        if psi1 < psi0:
            thtable = np.flip(thtable,axis=0)
            nutable = np.flip(nutable,axis=0)

        # The last contour can be used to define separatrix location,
        # we just prune it as the number of points affect how fast the
        # Boozer evaluation in ASCOT5 is.
        cr = interp1d(thgrid, np.append(r, r[0]), "linear")(thgeogrid)
        cz = interp1d(thgrid, np.append(z, z[0]), "linear")(thgeogrid)

        #Create input
        return ("Boozer", {
            "psimin":psimin, "psimax":psimax, "npsi":int(psigrid.size),
            "ntheta":int(thbzrgrid.size), "nthetag":int(thgeogrid.size),
            "rmin":1, "rmax":2, "nr":2,
            "zmin":1, "zmax":2, "nz":2,
            "r0":1, "z0":1, "psi0":psi0, "psi1":psi1,
            "psi_rz":np.zeros((2,2)), "theta_psithetageom":thtable,
            "nu_psitheta":nutable, "nrzs":int(cr.size), "rs":cr, "zs":cz} )

    def mhd_consistent_potentials(self, which="Phi", mhd=None):
        """Make MHD potentials consistent with E_par = 0 condition.

        This function adjusts the other potential so that the relation between
        the two is

        alpha * omega = Phi * sign * (n*q - m) / (I + g*q),

        which ensures that the parallel electric field is zero. The sign depends
        on whether the coordinate system is right- or left-handed (which depends
        on the orientation of psi).

        Parameters
        ----------
        which : {"Phi", "alpha"}, optional
            Which potential is modified while rest of the inputs are kept
            same.
        mhd : dict, optional
            Use the MHD data in this dictionary instead of using the active
            one in the HDF5 file.

        Returns
        -------
        gtype : str
            Type of the generated input data.
        data : dict
            Input data that can be passed to ``write_hdf5`` method of
            a corresponding type.
        """
        if which not in ["Phi", "alpha"]:
            raise ValueError("'which' must be either 'Phi' or 'alpha'")

        if mhd is None:
            mhd = self._ascot.data.mhd.active.read()
        else:
            mhd = copy.deepcopy(mhd)

        try:
            nrho = int(mhd["nrho"][0])
            n    = int(mhd["nmode"][0])
        except TypeError:
            nrho = int(mhd["nrho"])
            n    = int(mhd["nmode"])
        nmode = mhd["nmodes"]
        mmode = mhd["mmodes"]
        omega = mhd["omega"]
        rho = np.linspace(mhd["rhomin"], mhd["rhomax"], nrho)

        q, I, g = self._ascot.input_eval_safetyfactor(rho, nth=10000)
        q = q.ravel()
        I = I.ravel()
        g = g.ravel()

        if which == "Phi":
            phinm_ = np.zeros((n, nrho))
            for i in range(n):
                phinm_[i,:] = ( (g*q + I) / ( nmode[i] * q - mmode[i] ) ) \
                    * mhd["alpha"][:,i].T * omega[i]
            mhd["phi"] = phinm_.T
        elif which == "alpha":
            alphanm_ = np.zeros((n, nrho))
            for i in range(n):
                alphanm_[i,:] = ( ( nmode[i] * q - mmode[i] ) / (g*q + I) ) \
                    * mhd["phi"][:,i].T / omega[i]
            mhd["alpha"] = alphanm_.T

        return ("MHD_STAT", mhd)

    def marker_resonance(self, species=None, rhogrid=None, xigrid=None,
                         egrid=None, time=0*unyt.s):
        """Generate markers for estimating orbit resonances.

        All markers are generated at the outer mid plane at phi=0 at the nodes
        specified by the (rho, pitch, ekin) grid.

        Parameters
        ----------
        species : str
            Marker species to be simulated.
        rhogrid : array_like
            Grid of rho values where markers are initialized.
        xigrid : array_like
            Grid of pitch values where markers are initialized.
        egrid : array_like
            Grid of ekin values where markers are initialized.
        time : float, optional
            The time-instant at when the simulation begins.

        Returns
        -------
        gtype : str
            Type of the generated input data.
        data : dict
            Input data that can be passed to ``write_hdf5`` method of
            a corresponding type.
        """
        if rhogrid[0] < 0.0:
            raise ValueError("Minimum rho value must be larger than 0.0")
        if rhogrid[-1] > 1.0:
            raise ValueError("Maximum rho value must be smaller than 1.0")
        if xigrid[0] < -1.0:
            raise ValueError("Minimum pitch must be larger than -1.0")
        if xigrid[-1] > 1.0:
            raise ValueError("Maximum pitch must be smaller than 1.0")
        if egrid[0] < 0:
            raise ValueError("Minimum energy must be larger than 0.0")

        # Having pitch equal to +-1 in ASCOT causes trouble so we pad the values
        # a little bit
        if xigrid[0] == -1.0:
            xigrid[0] += 0.01 * (xigrid[-1] - xigrid[0]) / xigrid.size
        if xigrid[-1] ==  1.0:
            xigrid[-1] -= 0.01 * (xigrid[-1] - xigrid[0]) / xigrid.size

        rgrid, zomp = self._ascot.input_rhotheta2rz(
            rhogrid, 0.0*unyt.deg, 0.0*unyt.deg, time)

        nmrk = rhogrid.size * xigrid.size * egrid.size
        ekin, pitch, r = np.meshgrid(egrid, xigrid, rgrid, indexing='ij')

        mrk = Marker.generate("gc", nmrk, species=species)
        mrk["r"][:]      = r.ravel()
        mrk["z"][:]      = zomp[0] # Same for all markers
        mrk["phi"][:]    = 0.0*unyt.deg
        mrk["pitch"][:]  = pitch.ravel()
        mrk["time"][:]   = time
        mrk["energy"][:] = ekin.ravel()

        return ("gc", mrk)

    def options_singleorbit(self, npol=1, ntor=1, mode='gc'):
        """Generate options to trace markers for a fixed number of orbits.

        Collisionless orbits are traced for a fixed number of toroidal or
        poloidal transits. The points, where the given poloidal and toroidal
        planes were crossed, are recorded.

        Parameters
        ----------
        ntor : int
            Number of full toroidal orbits before simulation is terminated.
        npol : int
            Number of full poloidal orbits before simulation is terminated.
        mode : {'prt', 'gc'}
            Simulation mode.

        Returns
        -------
        gtype : str
            Type of the generated input data.
        data : dict
            Input data that can be passed to ``write_hdf5`` method of
            a corresponding type.
        """
        out = Opt.get_default()
        out.update({
            "ENABLE_ORBIT_FOLLOWING":1,
            "ENABLE_ORBITWRITE":1,
            "ORBITWRITE_MODE":0,
            "ORBITWRITE_TOROIDALANGLES":0.0,
            "ORBITWRITE_POLOIDALANGLES":0.0,
            "ORBITWRITE_NPOINT":200,
            "ENDCOND_MAX_POLOIDALORBS":npol,
            "ENDCOND_MAX_TOROIDALORBS":ntor,
            "ENDCOND_MAXORBS":1,
        })
        if mode == "gc":
            out.update({
                "SIM_MODE":2,
                "ENABLE_ADAPTIVE":1,
            })
        elif mode == "prt":
            out.update({
                "SIM_MODE":1,
            })
        return ("opt", out)
