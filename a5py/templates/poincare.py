"""Poincare run templates.
"""
import numpy as np
import unyt

from scipy.interpolate import interp1d
from scipy.integrate import solve_ivp, cumtrapz

from a5py.ascot5io.marker  import Marker
from a5py.ascot5io.options import Opt
from a5py.physlib import parseunits
from a5py.exceptions import *

class PoincareTemplates():

    def marker_poincare(self, nmrk=100, rhomin=0, rhomax=1, tor=None,
                        pol=0*unyt.deg, time=0*unyt.s, pitch=1.0, species=None,
                        energy=None):
        """Generate markers at fixed intervals in radius.

        By default, the generated markers are field lines. Physical particles
        can be generated by passing marker species and mass.

        Parameters
        ----------
        nmrk : int, optional
            Number of markers.
        rhomin : float, optional
            Minimum marker initial rho coordinate.
        rhomax : float, optional
            Maximum marker initial rho coordinate.
        tor : float, optional
            Initial marker toroidal coordinate.

            If None, markers are distributed uniformly in toroidal direction.
        pol : float, optional
            Initial marker poloidal coordinate.

            If None, markers are distributed uniformly in poloidal direction.
        time : float
            Time slice at when field line markers are traced.

            If physical particles are traced, this is the time-instant at when
            the simulation begins.
        pitch : float
            Field line marker direction (1) co- (2) counter-parallel to
            the magnetic field lines.

            If physical particles are traced, this parameter is the guiding
            center pitch (ppar/p) instead.

        species : str, optional
            Marker species to be simulated instead of field lines.

            **IMPORTANT** The simulation mode also needs to be set to GO or GC.
        energy : float
            Marker energy if physical particles are traced.

        Returns
        -------
        gtype : str
            Type of the generated input data.
        data : dict
            Input data that can be passed to ``write_hdf5`` method of
            a corresponding type.

        Raises
        ------
        ValueError
            If species is provided but not energy.
        """
        if species is not None and energy is None:
            raise ValueError("Please provide both species and energy")

        if tor is None:
            tor = 360 * np.random.rand(nmrk,) * unyt.deg
        else:
            tor = tor * np.ones((nmrk,))

        if pol is None:
            pol = 360 * np.random.rand(nmrk,) * unyt.deg
        else:
            pol = pol * np.ones((nmrk,))

        rhovals = np.linspace(rhomin, rhomax, nmrk)
        r, z = self._ascot.input_rhotheta2rz(rhovals, pol, tor, time)

        if species is None:
            mrk = Marker.generate("fl", nmrk)
            mrk["r"][:]     = r
            mrk["z"][:]     = z
            mrk["phi"][:]   = tor
            mrk["pitch"][:] = pitch
            mrk["time"][:]  = time
            return ("fl", mrk)
        else:
            mrk = Marker.generate("gc", nmrk, species=species)
            mrk["r"][:]      = r
            mrk["z"][:]      = z
            mrk["phi"][:]    = tor
            mrk["pitch"][:]  = pitch
            mrk["time"][:]   = time
            mrk["energy"][:] = energy
            return ("gc", mrk)

    @parseunits(tor="deg", pol="deg")
    def options_poincare(self, simmode=4, tor=0*unyt.deg, pol=0*unyt.deg,
                         ntorb=500, nporb=500, both=False, maxrho=False,
                         mhd=False, cpulim=None):
        """Generate options to generate Poincar√© plot data.

        Collisionless orbits are traced for a fixed number of toroidal and
        poloidal transits. The points, where the given poloidal and toroidal
        planes were crossed, are recorded.

        Parameters
        ----------
        simmode : {1, 2, 4}, optional
            Simulation mode (1: gyro-orbit, 2: guiding-center, 4: field line).
        tor : array_like, optional
            Toroidal angle(s) where data is gathered for (R,z) plot(s).
        pol : array_like, optional
            Poloidal angle(s) where data is gathered for (rho,phi) plot(s).
        ntorb : int, optional
            Number of full toroidal orbits before simulation is terminated.
        nporb : int, optional
            Number of full poloidal orbits before simulation is terminated.
        both : bool, optional
            Both ``ntorb`` and ``nporb`` conditions must be met before
            simulation is terminated.
        maxrho : bool, optional
            Terminate marker when it escapes plasma.

            Otherwise the marker is terminated at the wall.
        mhd : bool, optional
            Set ``True`` to enable MHD.
        cpulim : float, optional
            Maximum CPU time spent on simulating a single marker.

            This parameter can be used to ensure the simulation is terminated.

        Returns
        -------
        gtype : str
            Type of the generated input data.
        data : dict
            Input data that can be passed to ``write_hdf5`` method of
            a corresponding type.
        """
        out = Opt.get_default()
        out.update({
            "SIM_MODE":simmode,
            "ENABLE_ADAPTIVE":1,
            "ENABLE_ORBIT_FOLLOWING":1,
            "ENABLE_ORBITWRITE":1,
            "ORBITWRITE_MODE":0,
            "ORBITWRITE_TOROIDALANGLES":tor,
            "ORBITWRITE_POLOIDALANGLES":pol,
            "ORBITWRITE_NPOINT":nporb*pol.size + ntorb*tor.size,
            "ENDCOND_MAX_POLOIDALORBS":nporb,
            "ENDCOND_MAX_TOROIDALORBS":ntorb,
            "ENDCOND_MAXORBS":1,
            "ENDCOND_WALLHIT":1,
            "ENDCOND_MAX_RHO":1.0,
        })

        if both:
            out["ENDCOND_MAXORBS"] = 2
        if maxrho:
            out["ENDCOND_RHOLIM"] = 1
        if cpulim is not None:
            out["ENDCOND_CPUTIMELIM"]  = 1
            out["ENDCOND_MAX_CPUTIME"] = cpulim
        if mhd:
            out["ENABLE_MHD":mhd]

        return ("opt", out)

    def boozer_tokamak(self, npsi=100, nthgeo=200, nthbzr=200, tol=1e-5,
                       nint=10000, rhomin=0.3, rhomax=0.9):
        """Build mapping from real-space to Boozer coordinates assuming
        axisymmetric tokamak field.

        Parameters
        ----------
        npsi : int, optional
            Number of psi grid points.
        nthgeo : int, optional
            Number of geometrical theta grid points.
        nthbzr : int, optional
            Number of boozer theta grid points.
        nint : int, optional
            Number of points in line integral evaluations.
        rhomin : float, optional
            Minimum rho in the radial grid which cannot be zero since
            the Boozer coordinates cannot be computed there.
        rhomax : float, optional
            Maximum rho in the radial grid which cannot be one since
            the separatrix does not form a closed surface when there is
            an X-point.

        Returns
        -------
        gtype : str
            Type of the generated input data.
        data : dict
            Input data that can be passed to ``write_hdf5`` method of
            a corresponding type.
        """
        inp = self._ascot.input_initialized()
        if "bfield" not in inp:
            raise AscotInitException("bfield not initialized")
        grp   = self._ascot.data._get_group(inp["bfield"])
        gtype = grp.get_type()
        if gtype == "B_2DS":
            d = grp.read()
            rmin   = d["rmin"]
            rmax   = d["rmax"]
            nrcntr = int(d["nr"])
            zmin   = d["zmin"]
            zmax   = d["zmax"]
            nzcntr = int(d["nz"])
            psi0   = d["psi0"]
            psi1   = d["psi1"]
            raxis  = d["axisr"]
            zaxis  = d["axisz"]
            del d
        else:
            raise AscotNoDataException("bfield is not B_2DS")

        # The boozer coordinate system is constructed by integrating along
        # psi = constant surfaces. Use this grid to evaluate psi values
        # on a (R,z) plane.
        rgrid = np.linspace(rmin, rmax, nrcntr)
        zgrid = np.linspace(zmin, zmax, nzcntr)

        # ...and this poloidal grid to evaluate values along the contour
        thgrid = np.linspace(0, 2*np.pi, nint)

        # Boozer coordinate psi-grid. Add a little bit of padding to psi0 and
        # psi1 values as otherwise making the contour at those points could
        # yield funny results.
        pmin  = float(psi0 + rhomin**2 * ( psi1 - psi0 ))
        pmax  = float(psi0 + rhomax**2 * ( psi1 - psi0 ))
        psimin  = np.amin([pmin, pmax])
        psimax  = np.amax([pmin, pmax])
        psigrid = np.linspace(psimin, psimax, npsi)
        if psi1 < psi0: psigrid = np.flip(psigrid) # Ensure grid start at psi0

        # Boozer coordinate theta grid
        thgeogrid = np.linspace(0, 2*np.pi, nthgeo)

        # Boozer coordinate nu grid
        thbzrgrid = np.linspace(0, 2*np.pi, nthbzr+1)[:-1]

        # Set up the data tables (psi can be evaluated directly)
        thtable  = np.zeros( (psigrid.size, thgeogrid.size) )
        nutable  = np.zeros( (psigrid.size, thbzrgrid.size) )
        psitable = self._ascot.input_eval(
            rgrid*unyt.m, 0*unyt.deg, zgrid*unyt.m, 0*unyt.s, "psi", grid=True)
        psitable = np.squeeze(psitable)

        # Helper quantities evaluated when the coordinate transform is made
        qprof = np.zeros(psigrid.shape)
        Iprof = np.zeros(psigrid.shape)
        gprof = np.zeros(psigrid.shape)

        # Calculate Boozer angular coordinates for each psi
        for i in range(psigrid.size):

            # Interpolate the contour points on the fixed (geometrical) theta
            # grid (at OMP we set thetageom=thetabzr=0)
            rhogrid = np.sqrt((psigrid[i]-psi0) / (psi1 - psi0)) \
                * np.ones(thgrid.shape)*unyt.dimensionless
            r, z = self._ascot.input_rhotheta2rz(
                rhogrid, thgrid*unyt.rad, np.zeros(thgrid.shape)*unyt.rad,
                0*unyt.s, tol=tol)

            # Magnetic field along the contour (psi can be used to check that
            # the contour was set properly). Drop the last element in r and z
            # as it is the same as first.
            br, bphi, bz, psi = self._ascot.input_eval(
                r[:-1], 0*unyt.rad, z[:-1], 0*unyt.s,
                "br", "bphi", "bz", "psi")

            bpol  = np.sqrt(br**2 + bz**2)
            bnorm = np.sqrt(br**2 + bphi**2 + bz**2)
            ds    = (np.diff(r) * br + np.diff(z) * bz) / bpol # darc dot e^_pol
            r = r[:-1]; z = z[:-1]

            # The toroidal current term (multiplying this with mu0/2 pi gets
            # enclosed toroidal current)
            Iprof[i] = np.sum( ds * bpol ) / ( 2*np.pi )

            # g = R*Bphi, since Bphi ~ 1/R this is a constant
            gprof[i] = r[0] * bphi[0]

            # The (global) safety factor q(psi)
            qprof[i] = np.sum( ds * gprof[i] / ( r**2 * bpol ) ) / ( 2*np.pi )

            # Boozer coordinate Jacobian is (I - qg) / B^2. Setting it fixes the
            # Boozer poloidal angle which we can now solve.
            jac = (Iprof + qprof*gprof)[i] / bnorm**2
            btheta = np.append(0, np.cumsum( ds / ( jac * bpol ) ))

            # The above Jacobian is for a periodical theta, so theta[-1] should
            # equal to 2 pi already, but normalize it to remove numerical error
            # (note that the new Jacobian would be J / a)
            a = 2*np.pi / btheta[-1]
            btheta *= a
            thtable[i, :] = interp1d(thgrid, btheta, "linear")(thgeogrid)

            # For Boozer toroidal coordinate, we need to integrate the local
            # safety factor along the contour
            nu = gprof[i] * np.append(0, np.cumsum( ds / ( r**2 * bpol ) ) )

            # Interpolate nu used in zeta = phi + nu(psi, theta)
            nutable[i,:] = -interp1d(btheta, nu, 'linear')(thbzrgrid) \
                + qprof[i] * thbzrgrid

        # Flip the data grids to set indices right
        if psi1 < psi0:
            thtable = np.flip(thtable,axis=0)
            nutable = np.flip(nutable,axis=0)

        # The last contour can be used to define separatrix location
        cr = np.append(r, r[0])
        cz = np.append(z, z[0])

        #Create input
        return ("Boozer", {
            "psimin":psimin, "psimax":psimax, "npsi":int(psigrid.size),
            "ntheta":int(thbzrgrid.size), "nthetag":int(thgeogrid.size),
            "rmin":rgrid[0], "rmax":rgrid[-1], "nr":int(rgrid.size),
            "zmin":zgrid[0], "zmax":zgrid[-1], "nz":int(zgrid.size),
            "r0":raxis, "z0":zaxis, "psi0":psi0, "psi1":psi1,
            "psi_rz":psitable, "theta_psithetageom":thtable,
            "nu_psitheta":nutable, "nrzs":int(cr.size), "rs":cr, "zs":cz} )
