/**
 * @file diag.c
 * @brief Interface for simulation diagnostics
 *
 * Ascot standard output consists of inistate and endstate. Any other output is
 * generated by "diagnostics" that are updated during the simulation. All
 * diagnostics are accessed via this interface. To implement a new diagnostics,
 * it is enough that one add calls to that diagnostics routines here.
 *
 * One limitation for diagnostic data is that the size of the data must be known
 * before simulation begins so that offloading of that data is possible.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "ascot5.h"
#include "simulate.h"
#include "B_field.h"
#include "diag.h"
#include "diag/diag_orb.h"
#include "diag/dist_5D.h"
#include "diag/dist_6D.h"
#include "diag/dist_rho5D.h"
#include "diag/dist_rho6D.h"
#include "diag/dist_com.h"
#include "diag/diag_transcoef.h"
#include "particle.h"
#include "simulate.h"

/**
 * @brief Initializes diagnostics data
 *
 * @param data diagnostics data
 * @param nmarkers number of markers in the simulation
 */
int diag_init(sim_data* sim, int nmarkers) {

    if(sim->params->collect_dist5d) {
        dist_5D_init(sim->dist5d, sim->params);
    }

    if(sim->params->collect_dist6d) {
        dist_6D_init(sim->dist6d);
    }

    if(sim->params->collect_dist5drho) {
        dist_rho5D_init(sim->dist5drho);
    }

    if(sim->params->collect_dist6drho) {
        dist_rho6D_init(sim->dist6drho);
    }

    if(sim->params->collect_distcom) {
        dist_COM_init(sim->distcom);
    }

    if(sim->params->collect_orbit) {
        diag_orb_init(sim->orbit, sim->params, nmarkers);
    }

    if(sim->params->collect_transport_coefficient) {
        diag_transcoef_init(sim->transport_coefficient, sim->params, nmarkers);
    }

    return 0;
}

/**
 * @brief Free allocated resources
 *
 * @param data diagnostics data
 */
void diag_free(sim_data* sim) {
    if(sim->params->collect_dist5d) {
        dist_5D_free(sim->dist5d);
    }
    if(sim->params->collect_dist6d) {
        dist_6D_free(sim->dist6d);
    }
    if(sim->params->collect_dist5drho) {
        dist_rho5D_free(sim->dist5drho);
    }
    if(sim->params->collect_dist6drho) {
        dist_rho6D_free(sim->dist6drho);
    }
    if(sim->params->collect_distcom) {
        dist_COM_free(sim->distcom);
    }
    if(sim->params->collect_orbit) {
        diag_orb_free(sim->orbit, sim->params);
    }
    if(sim->params->collect_transport_coefficient) {
        diag_transcoef_free(sim->transport_coefficient);
    }
}

/**
 * @brief Offload data to the accelerator.
 *
 * @param data pointer to the data struct
 */
void diag_offload(sim_data* sim) {
    if(sim->params->collect_dist5d) {
        dist_5D_offload(sim->dist5d);
    }
    if(sim->params->collect_dist6d) {
        dist_6D_offload(sim->dist6d);
    }
    if(sim->params->collect_dist5drho) {
        dist_rho5D_offload(sim->dist5drho);
    }
    if(sim->params->collect_dist6drho) {
        dist_rho6D_offload(sim->dist6drho);
    }
    if(sim->params->collect_distcom) {
        dist_COM_offload(sim->distcom);
    }
}

/**
 * @brief Collects diagnostics when marker represents a particle
 *
 * @param data diagnostics data struct
 * @param Bdata pointer to magnetic field data
 * @param p_f pointer to SIMD struct storing marker states at the end of current
 *        time-step
 * @param p_i pointer to SIMD struct storing marker states at the beginning of
 *        current time-step
 */
void diag_update_fo(sim_data* sim, B_field_data* Bdata, particle_simd_fo* p_f,
                    particle_simd_fo* p_i) {
    if(sim->params->collect_orbit) {
        diag_orb_update_fo(sim->orbit, sim->params, p_f, p_i);
    }
    if(sim->params->collect_dist5d) {
        dist_5D_update_fo(sim->dist5d, sim->params, p_f, p_i);
    }
    if(sim->params->collect_dist6d) {
        dist_6D_update_fo(sim->dist6d, p_f, p_i);
    }
    if(sim->params->collect_dist5drho) {
        dist_rho5D_update_fo(sim->dist5drho, p_f, p_i);
    }
    if(sim->params->collect_dist6drho) {
        dist_rho6D_update_fo(sim->dist6drho, p_f, p_i);
    }
    if(sim->params->collect_distcom){
        dist_COM_update_fo(sim->distcom, Bdata, p_f, p_i);
    }
    if(sim->params->collect_transport_coefficient){
        diag_transcoef_update_fo(sim->transport_coefficient, sim->params, p_f, p_i);
    }
}

/**
 * @brief Collects diagnostics when marker represents a guiding center
 *
 * @param data pointer to diagnostics data struct
 * @param Bdata pointer to magnetic field data
 * @param p_f pointer to SIMD struct storing marker states at the end of current
 *        time-step
 * @param p_i pointer to SIMD struct storing marker states at the beginning of
 *        current time-step
 */
void diag_update_gc(sim_data* sim, B_field_data* Bdata, particle_simd_gc* p_f,
                    particle_simd_gc* p_i) {
    if(sim->params->collect_orbit) {
        diag_orb_update_gc(sim->orbit, sim->params, p_f, p_i);
    }
    if(sim->params->collect_dist5d){
        dist_5D_update_gc(sim->dist5d, sim->params, p_f, p_i);
    }
    if(sim->params->collect_dist6d){
        dist_6D_update_gc(sim->dist6d, p_f, p_i);
    }
    if(sim->params->collect_dist5drho){
        dist_rho5D_update_gc(sim->dist5drho, p_f, p_i);
    }
    if(sim->params->collect_dist6drho){
        dist_rho6D_update_gc(sim->dist6drho, p_f, p_i);
    }
    if(sim->params->collect_distcom){
        dist_COM_update_gc(sim->distcom, Bdata, p_f, p_i);
    }
    if(sim->params->collect_transport_coefficient){
        diag_transcoef_update_gc(sim->transport_coefficient, sim->params, p_f, p_i);
    }
}

/**
 * @brief Collects diagnostics when marker represents a magnetic field line
 *
 * Distributions are not updated for magnetic field lines.
 *
 * @param data pointer to diagnostics data struct
 * @param p_f pointer to SIMD struct storing marker states at the end of current
 *        time-step
 * @param p_i pointer to SIMD struct storing marker states at the beginning of
 *        current time-step
 */
void diag_update_ml(sim_data* sim, particle_simd_ml* p_f,
                    particle_simd_ml* p_i) {
    if(sim->params->collect_orbit) {
        diag_orb_update_ml(sim->orbit, sim->params, p_f, p_i);
    }
    if(sim->params->collect_transport_coefficient){
        diag_transcoef_update_ml(sim->transport_coefficient, sim->params, p_f, p_i);
    }
}
